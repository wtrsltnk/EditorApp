// Model.cpp: implementation of the Model class.
//
//////////////////////////////////////////////////////////////////////

#include "Model.h"
#include <string>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

Model::Model(const char* name)
{
	Name(name);
	this->currentSequence = 0;
}

Model::~Model()
{
	ClearMeshGroups();
	ClearSequences();
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::ClearMeshGroups()
{
	for (int i = 0; i < this->meshGroups.Size(); i++)
		delete this->meshGroups.Get(i);

	this->meshGroups.Clear();
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::ClearSequences()
{
	for (int i = 0; i < this->sequences.Size(); i++)
		delete this->sequences.Get(i);

	this->sequences.Clear();
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::SetupJoints()
{
	this->skeleton.SetupJoints();

	for (int i = 0; i < this->meshGroups.Size(); i++)
	{
		MeshGroup* meshgroup = this->meshGroups[i];

		for (int j = 0; j < meshgroup->GetMeshCount(); j++)
		{
			Mesh* mesh = meshgroup->GetMesh(j);

			Collection <Point*> points = mesh->GetPoints();

			for (int k = 0; k < points.Size(); k++)
			{
				Joint* joint = this->skeleton.GetJoint(this->skeleton.GetJointIndex(points[k]->Joint()));

				joint->FromZero().inverseTranslateVect(points[k]->AnimPosition());
				joint->FromZero().inverseRotateVect(points[k]->AnimPosition());
				joint->FromZero().inverseRotateVect(points[k]->AnimNormal());
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
const char* Model::Name()
{
	return this->name;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::Name(const char* name)
{
	strcpy(this->name, name);
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
int Model::GetFrameCount()
{
	return 0;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
int Model::GetCurrentFrame()
{
	return 0;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::AdvanceFrame(float amount)
{
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::GotoFrame(int frame)
{
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::SetSkeleton(Skeleton* skeleton)
{
	memcpy(&this->skeleton, skeleton, sizeof(Skeleton));
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
Skeleton* Model::GetSkeleton()
{
	return &this->skeleton;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::AddMeshGroup(MeshGroup* meshgroup)
{
	this->meshGroups.Add(meshgroup);
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
bool Model::RemoveMeshGroup(const char* meshgroup)
{
	int i = GetMeshGroupIndex(meshgroup);
	
	if (i > -1)
	{
		this->meshGroups.Remove(i);
	}
	return false;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
MeshGroup* Model::GetMeshGroup(const char* meshgroup)
{
	int i = GetMeshGroupIndex(meshgroup);

	if (i > -1)
		return this->meshGroups[i];

	return 0;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
int Model::GetMeshGroupIndex(const char* meshgroup)
{
	if (meshgroup)
	{
		for (int i = 0; i < this->meshGroups.Size(); i++)
		{
			if (strcmp(this->meshGroups[i]->Name(), meshgroup) == 0)
			{
				return i;
			}
		}
	}
	return -1;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::AddSequence(Sequence* seq)
{
	if (this->sequences.Add(seq) >= 0)
		this->currentSequence = seq;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
bool Model::RemoveSequence(const char* seq)
{
	int i = GetSequenceIndex(seq);
	
	if (i > -1)
	{
		this->sequences.Remove(i);
	}
	return false;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
Sequence* Model::GetSequence(const char* seq)
{
	int i = GetSequenceIndex(seq);

	if (i > -1)
		return this->sequences[i];

	return 0;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
int Model::GetSequenceIndex(const char* seq)
{
	if (seq)
	{
		for (int i = 0; i < this->sequences.Size(); i++)
		{
			if (strcmp(this->sequences[i]->Name(), seq) == 0)
			{
				return i;
			}
		}
	}
	return -1;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
int Model::GetMeshGroupCount()
{
	return this->meshGroups.Size();
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
MeshGroup* Model::GetMeshGroup(int index)
{
	return this->meshGroups[index];
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
int Model::GetSequenceCount()
{
	return this->sequences.Size();
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
Sequence* Model::GetSequence(int index)
{
	return this->sequences[index];
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::SetCurrentSequence(int index)
{
	if (index >= 0 && index < this->sequences.Size())
	{
		this->currentSequence = this->sequences[index];
	}
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
void Model::SetCurrentSequence(const char* seq)
{
	if (int index = GetSequence(seq) >= 0)
		this->currentSequence = this->sequences[index];
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
Sequence* Model::GetCurrentSequence()
{
	return this->currentSequence;
}

//////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
//////////////////////////////////////////////////////////////////////
bool Model::IsReady()
{
	return true;
}
